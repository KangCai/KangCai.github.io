---
layout: post
title: "游戏 AI - 11"
subtitle: "转向行为II"
author: "Kang Cai"
header-img: "img/post-bg-dreamer.jpg"
header-mask: 0.4
tags:
  - 游戏 AI
---


我们已经介绍了多个基本构建块行为：“寻找” 和 “逃离”，“到达”，和“对齐”。

接下来要介绍的所有行为都有相同的基本结构：它们计算一个目标，或者一个位置或方向(它们可以使用速度，但我们将不涉及这些)，然后它们委托给其他行为之一来计算转向。目标计算可以基于许多输入。例如，“追赶” 根据另一个目标的运动为 “寻找” 计算目标；碰撞避免基于近似障碍的方法创造一个目标来逃离；而 “漫游” 则创造了它自己的目标，在它移动的过程中蜿蜒而行。

事实上，“寻找”、“对齐”和“速度匹配”是唯一的基本行为(通过类比，有一个旋转匹配行为，但我从未见过它的应用程序)。正如我们在前面的算法中看到的，“到达” 可以分为 “创建(速度)目标” 和应用 “速度匹配” 算法。下面的许多委托行为可以反过来作为另一个委托行为的基础，“到达” 算法可以作为 “追赶” 的基础，而“追赶” 算法又可以作为其他算法的基础，等等。

在下面的代码中，我将使用多态风格的编程来捕获这些依赖关系。您也可以使用委托，让原语算法由新技术调用。这两种方法都有各自的问题。在我们的例子中，当一个行为扩展另一个行为时，通常是通过计算替代目标来实现的。使用继承意味着我们需要能够更改超类工作的目标。

如果我们使用委托方法，我们需要确保每个委托行为都有正确的字符数据、maxAcceleration和其他参数。这需要使用子类删除的复制和数据复制。

## 一、追逐 和 逃避

到目前为止，我们只根据位置移动。如果我们追逐一个移动的目标，那么不断地向它当前的位置移动是不够的。当我们到达它现在的位置时，它已经移动了。当目标离我们很近，并且我们在每一帧都要重新考虑它的位置时，这并不是什么大问题。我们最终会到达那里的。但是如果角色离目标很远，它就会朝着一个明显错误的方向出发，如图3.11所示。

<img src="https://kangcai.github.io/img/in-post/post-gameai/12.1.PNG"/>

我们需要预测它在未来某个时候的位置，并朝着那个方向努力，而不是瞄准它当前的位置。我们小时候玩捉迷藏的游戏，很自然为什么最难抓住的标签玩家是那些不断改变方向，破坏我们预测的人。

我们可以使用各种算法来进行预测，但大多数都是过犹不及的。针对被追逐角色的最佳预测和最佳策略已经进行了各种研究(例如，躲避来袭导弹是军事研究中一个活跃的话题)。克雷格·雷诺兹最初的方法简单得多:我们假设目标将继续以相同的速度移动，它目前已经。在短距离中这是一个合理的假设，即使是在较长的距离中，这也不会显得太愚蠢。

该算法计算出角色与目标之间的距离，并计算出以最大速度到达目标需要多长时间。它使用这个时间间隔作为它的预测前向。如果目标继续以当前速度移动，它会计算目标的位置。然后，这个新位置被用作标准寻求行为的目标。

如果人物移动缓慢，或者目标距离很远，预测时间可能会非常长。目标不太可能永远沿着同一条道路走下去，所以我们要为我们的目标设定一个限度。因此，该算法有一个最大时间参数。如果预测时间超过这个值，则使用最大时间。

图3.12所示为追求同一目标的寻求行为和追求行为。追求行为在追求中更有效。

### 1.1 伪代码

“追逐”（pursue）行为源于 “寻找”（seek），计算一个代理目标，然后委托seek 执行转向计算：

<img src="https://kangcai.github.io/img/in-post/post-gameai/12.2.PNG"/>

```buildoutcfg
# Work out the distance to target.
direction = target.position - character.position
distance = direction.length()

# Work out our current speed.
speed = character.velocity.length()

# Check if speed gives a reasonable prediction time.
if speed <= distance / maxPrediction:
    prediction = maxPrediction
# Otherwise calculate the prediction time.
else:
    prediction = distance / speed

# Put the target together.
Seek.target = explicitTarget
Seek.target.position += target.velocity * prediction

# 2. Delegate to seek.
return Seek.getSteering()
```

### 1.2 性能

时间和空间复杂度仍都是 O(1)。

### 1.3 规避

追逐的反面行为是规避，在代码中将继承于 Seek 改成 Flee，最终返回值也从 `Seek.getSteering` 变为 `Flee.getSteering`。