
# ELEMENTS OF PROGRAMMING INTERVIEWS IN PYTHON

PYTHON 编程面试的要素

## 简介

此书目标在于帮助软件工程师的面试。专注方向包括：数据结构、算法、系统设计以及问题解决。大多以问题的方式展现。

## 第一部分：面试

面试流程通常包括下列步骤：

（1）识别定位感兴趣的公司，最好找在职员工了解详情；
（2）通过内推、官网投递、校招等方式投递简历；
（3）电话面试（外企流程）；
（4）线下面试，通常包括工程师、经理、HR等；
（5）接收 offer，开始协商合同。

面试的非技术方面：

（1）面试流程；
（2）面试技巧；
（3）职业品质；
（4）面试演练。

## 第二部分：数据结构和算法

### 基本类型

** 知识库**

1. 熟练使用位运算，特别是 XOR 异或操作
2. 理解如何使用 masks 掩码，并且用一种与机器无关的方式创建它们 (?)
3. 知道清除最后一个1的最快方式（扩展问题，置最后一位为0、获取某一位的下标）
4. 理解有符号类型，并且它对偏移量的影响
5. 考虑用缓存来用在小输入情况下进行加速运算

#### 计算一个数二进制形式的奇偶性 <+>

* 题干
    * 二进制形式下1的个数为奇数，则就奇偶性为1；若1的个数为偶数，则奇偶性为0；
* 解法
    * O(n): 直接算个数
    * O(k): `x&=x-1` 快速置末尾1
    * O(n/l): l 为哈希段长度，哈希总数为 2^l 个，比如对于 64bit 数字，可以取 l = 16
    * O(logn): 巧妙方法，使用 XOR 操作，直接两两分段抵消 `x^=x>>32`
    * 结合: 先 XOR 两次到 16 长度，然后再直接 hash
* 变种：O(1) 时间复杂度求解问题
    * 右向传播最右的置位，比如 01010000 变成 010111111: `x|=x-1`
    * 求 x 关于 2 的指数幂的模，比如 77 模 64 是 13: 相当于左侧的对应长度置位改成0，`x&=64-1`
    * 判断一个数是否是 2 的指数幂：`x^(x-1)==0`
    * 提取出最低位：`x^~(x-1)`
    
#### 交换比特位

* 题干
    * 交换下标为 i、j 的两个位
* 解法
    * O(n): 当做数组暴力求解
    * O(1): i、j 两位取出来，组成 j、i 位置上的新数，然后加到清掉 i、j 位置的原数
    * O(1): 更快捷的方式，由于 i、j 位的值相同时，不用做任何操作；i、j 位的值不同时，直接反转各自即可 `if (x>>i)&1 != (x>>j)&1: x ^= (1<<i) | (1<<j)`
* 思考
    * 什么时候回用到交换比特位？

#### 反转二进制

* 题干
    * 反转 x 的二进制表示
* 解法
    * O(n/l): l 为哈希段长度，比如 l 为 16，即每段 16，分段查表再重新拼接
    
#### 找到最近的同二进制重量的数

* 题干
    * 找到 x 最近的二进制重量的数，其中二进制重量指的是数在二进制表示下1的总个数
* 示例
    * 100101 的重量为 3，最近二进制重量的数是 100110，重量同样是 3，值相差 1
* 解法
    * O(2^n): 暴力解法，`x-1,x+1,x-2,x+2,...` 尝试
    * O(n): 借助交换比特位，从 0 位开始，如果第 k 和 k+1 的值不一样，则交换两位，交换后就是解。如果所有位都是0或1，则没有解

#### 在不使用算术符的前提下，求解 x * y

* 题干
    * 只能使用 `=`、`>>`、`<<`、`|`、`&`、`~`、`^`、`==`、`!=`、`and`、`or`、`!`，其中 x, y 均为整数
* 解法，设 x 的长度为 n 比特位
    * O(n*2^n): 暴力把 x 自加 y 遍，每个加法需要 `^` XOR n 遍
    * O(n^2)：可以采用二进制的错位相加，比如 13=(1101)，9=(1001)，那么可以从 13 的二进制表示的最低位开始，1001 + 0 + 1001<<2 + 1001<<3，同样，每个加法需要 `^` XOR n 遍
    
#### 限制性条件下，计算 x / y

* 题干
    * 只用 `+`、`-`、`>>`、`<<`，其中 x, y 均为整数
* 解法
    * O(2^n): 暴力解法，一个个减
    * O(n): 二进制，类似于 x * y 的问题，从 y 的 2^k（其中 k 是最高位数），开始比较起，`x >= y*2^k` 的情况下，减去 `y*2^k` ，并在输出结果的第 k 位上记下 1

#### 计算 x^y

* 题干
    * 计算 x*y，其中 x, y 均为整数
* 解法
    * O(2^n): 对 x 乘以 y 次
    * O(logy): x^y = x^(y/2) * x^(y/2) 考虑奇偶关系后续可能需要额外乘以 x
    * O(n): 与 logy 类似的思想，对于 y 的二进制表示。在 y 不为 0 之前，使 x 迭代自乘，若该位为 1，则当前数乘以 x 的迭代自乘数；然后无论该位如何，后续都再迭代自乘。另外 `y = y >> 1`。

#### 翻转数字

* 题干
    * 翻转一个数字，比如 1132，变成 2311
* 解法
    * O(n): 转成 string，然后翻转
    * O(n): 直接模 10，加到新数字上

#### 判断回文数字

* 题干
    * 判断一个十进制数是否是回文
* 解法
    * O(n)空间复杂度: 转成 string，遍历判断
    * O(1)空间复杂度: 通过除以10和求余，直接在数上比较和移除
    * O(1)空间复杂度: 先翻转数字，然后直接比较新数字和原数字
    
#### 生成均一的随机数字

* 题干
    * 6 名同学需要用一枚无偏差的硬币来挑出一名司机
* 解法
    * O(log(b-a+1)): 其中 \[a,b\] 是随机数范围。二进制 roll 法，有 2/8 概率没有得到 000 到 101 之间的数，10次内没 roll 到的概率就是 (2/8)^10，小于一百万分之一的概率。理论上，按单词 roll 成功概率是 1/2，那么期望是 2，即 O(1) 的时间复杂度，乘以二进制的位数，时间复杂度是 O(log(b-a+1))。

#### 矩形相交

* 题干
    * 判断两个平行于 x 和 y 轴的矩形是否相交
* 解法
    * O(1): 两个平行于 xy 轴的矩形相交的充要条件是 (R1.x<=R2.x+R2.width and R1.x+R1.width>=R2.x and R1.y<=R2.y+R2.height and R1.y+R1.height>=R2.y)
* 变种
    * 给出平面内四个点，判断他们是否是一个矩形的顶点: 四个点的中点，到四个点的距离相等，且形成两条对角线。
    * 如果不平行于 xy 轴，如何判断两个矩形相交 (?)
        * 第一步，判断点是否在矩形内，到所有点的三角形顶角和是360度
        * 第二步，判断 4边X4边 线段是否相交
        * 其中，判断线段相交
            * 第一步，快速排斥实验: 映射到坐标轴上看是否有重合，没有重合则必不相交。
            * 第二步，跨立实验: ADXCD * BDXCD<=0 表示 AB 在 CD 两端，同理也要证明 CD 在 AB 两端
            
### 数组

**数组提高营**

* 题干
    * 给定一个数组，要求返回一个偶数在前，奇数在后的调整顺序后的数组
* 解法
    * O(1)空间复杂度: 偶数与数组前指针位置互换，奇数与数组后指针位置互换，直到两个指针指到同一个位置

1. 数组问题通常有简单暴力的 O(n) 空间复杂度解法，但巧妙地利用数组本身往往可以降低复杂度到 O(1);
2. 从前往后填满数组如果比较慢，可以尝试从后往前填；
3. 与其删掉某个元素，不如尝试覆盖它，因为删掉需要把所有右边的元素都往左移一位；
4. 当处理把整数编排成数组形式的问题时，可以考虑翻转数组，使得数组第一位对应最小单位；
5. 熟练写关于子数组的操作；
6. 注意数组的最后一位，不要越界；
7. 不要担心数组的完整性（比如排序、相同的元素放在一起等等），可以在 return 前的最后一步做；
8. 当你提前知道元素的分布时，数组可以作为一个好的数据结构加以利用。比如，一个长度为 W 的 boolean 数组是表示 {0, 1,..., W-1} 子集的一个好办法；
9. 当操作二维数组时，可以对行和列使用并行逻辑；(?)
10. 有时候，模拟规则比解析式地求解问题更简单。比如，对于一个 nxn 的矩阵，与其写第 i 个元素的公式，不如从头开始计算输出。(?)

**知识库**

1. 知道初始化数组的语法，比如: `[3,5,7,11]`、`[1]+[0]*10`、`list(range(100))`;
2. 基础操作包括: `len(A)`, `A.append(42)`, `A.remove(2)`, and `A.insert(3,28)`;
3. 知道如何初始化一个二维数组，比如，`[[1,2,4],[3,5,7,9],[13]]`;
4. 检查一个元素是否在一个数组里: `a in A`，O(n)时间复杂度;
5. 明白复制的原理，比如 `B=A` 和 `B=list(A)` 间的差别。明白深拷贝是什么，以及它和浅拷贝的区别，即 `copy.copy(A)` 和 `copy.deepcopy(A)` 的区别；
6. 数组的重要方法包括: `min(A), max(A), bisect.bisect(A, 6), bisect.bisect_left(A, 6), bisect.bisect_right(A, 6), A.reverse(), reversed(A), A.sort(), sorted(A), del A[i], del A[i:j]`
7. 分割是一个非常简洁的操作数组的方式，它能被看作是索引的泛化: 分割最通用的形式是 `A[i:j:k]`，其中 k 是可选项;
8. 列表综合: `[x** for x in range(6) if x % 2 ==0]`

#### 荷兰国旗问题 (?)

#### 给任意精度的整数加一

* 题干
    * 一个非负十进制整数 D 表示为数组形式，更新该数组来表示整数 D+1，比如输入时 <1,2,9>，输出应该是 <1,3,0>
* 解法
    * O(n): 直接解
* 变种
    * 二进制整数表示为字符串形式的两个数 Bs 和 Bt，返回 Bs+Bt 的表示形式
    
#### 乘以两个任意精度的整数

* 题干
    * 比如 <1,9,3,7,0,7,7,2,1> 和 <-7,6,1,8,3,8,2,5,7,2,8,7>，函数返回 <-1,4,7,5,7,3,9,5,2,5,8,9,6,7,6,4,1,2,9,2,7>
* 解法
    * O(nm): 模拟乘法过程

#### 数组跳棋

* 题干
    * 比如 A = <3,3,1,0,2,0,1>，比如 index 为 0 时，最长步长为 3，则最多跳 3 步
* 解法
    * O(n^2): 动态规划
    * O(n): 贪心法，从数组头开始遍历，不断更新最远的 index; 

#### 从排序数组中删除重复元素

* 题干
    * 比如 <2,3,5,5,7,11,11,11,13>，删除后是 <2,3,5,7,11,13,0,0,0>
* 解法
    * O(n) time and O(1) space
* 变种 
    * 实现一个函数，给定数组和一个目标值，把数组中所有与目标值相等的元素给删掉，剩下的元素左移填满删掉的位置: O(n) time and O(1) space，双指针。
    * 写一个程序，给定排序数组 A 和正整数 m，更新 A 使得所有元素都出现 min(2,m) 次，其中 m 是该元素原本的出现次数，更新 A 的过程只能遍历一遍，并且不能创建任何额外的内存: 类似的，双指针。 
    
#### 买卖股票

* 题干
    * 给一个数组表示每天股票的价格，买卖一次股票达到最大利润
* 解法
    * O(n^2): 暴力解法，尝试所有组合
    * O(n): 遍历一遍，记录并更新最小值，同时更新最大利润

#### 买卖股票两次

* 题干
    * 给一个数组表示每天股票的价格，买卖两次股票达到最大利润，并且第二次买必须在第一次卖之后
* 解法
    * O(n^4): 暴力解法，尝试所有组合
    * O(n^2): 划定一个分割点，前后分别做两次买卖股票的操作
    * O(n): 动态规划，到 k 为止，第 i 次买或卖; i 为 2 (?)
    
#### 计算交替

* 题干
    * 给一个数组 A，重排 A 中的元素顺序得到一个新的数组 B，使得 B 具备如下性质: `B[0] <= B[1] >= B[2] <= B[3] >= B[4] <= B[5] >= ...`
* 解法
    * O(nlogn): 从小到大快排后，对调 2k+1 和 2k+2 (k=0,1,2,...)
    * O(n): 先找到中位数；遍历数组逐一与中位数比较，小的依次放奇数位，大的依次放偶数位
    
#### 枚举所有到 n 为止的质数

* 题干
    * 比如，输入是 18，你应该返回 <2,3,5,7,11,13,17>
* 解法
    * O(n^1.5): 从 2 到 k^0.5 遍历整数，当不存在一个数能被 k 整除，则是质数；外层的 k 遍历 n 遍
    * O(nloglogn): 设 n 为 10，则候选布尔数组为 <F,F,T,T,T,T,T,T,T,T>，其中 T 表示该位置是质数。从 2 开始，更新候选布尔数组 <F,F,T,T,F,T,F,T,F,T,F>；再依据 3 更新候选布尔数组 <F,F,T,T,F,T,F,T,F,F,F>，再从新布尔数组中后续的为 T 的 5 开始，... 总时间复杂度是 O(n/2+n/3+n/5+n/7+n/11)，渐进上限是 O(nloglogn)；其中渐进上限的证明见 [https://zhuanlan.zhihu.com/p/36272103](https://zhuanlan.zhihu.com/p/36272103)

